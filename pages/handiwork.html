<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ardylab</title>
  <link rel="shortcut icon"href="../images/myicon.ico">
  <link rel="stylesheet" href="../style.css">
</head>
<body>

  <header>
    <table >
     <tr>
      <td ><a href="../index.html"><img src="../images/logo.jpg" class="leftfoto"></a></td>
      <div>
        <td ><p> <br> Cсылка на мой старый сайт
          <a href="https://avtosega.blogspot.com/2022/01/blog-post.html"> Приглашаю!</a></p></td>
          <td>
          </div>
        </td>
      </tr>
    </table>
  </header>

  <div class="divdiv di"><a name="kontrolka"></a><p><b>Первый вариант многофункциональной контрольки с осцилографом.</b>(другие варианты ниже) <br/><br/>Выкладываю как есть, пока 2 функции вольтметр и осцилограф, доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, тест форсунок, генератор ШИМ, частотомер, генератор дпкв 60 -2.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
   <br/><br/> Защит каких либо не будет в первой версии точно, сгорит будет интерес починить, компоненты копеечные.
   Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет), лучше брать для изготовления ардуино нано с юсб с разьемом так как планируется нагрузка по минусу до 1 ампера.
   На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
   Питание с аккумулятора не планируется для простоты, все питание от авто.
   Генератор планируется с частотой до 1 килогерца и шим 0-100%.
   Тестер форсунок выдает импульсы в течении одой секуды что позволяет промерить относительный расход форсунки без снятия и без сканера с такой функцией  по падению давления на манометре.
   <br/><br/>
   Сам скетч контрольки в файле для скачивания <a href="../files/kontrolka.zip" download>   скачать   </a><br/>
   Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
   <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
   <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
   <br/>
   Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
   <br/>
   Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
   <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
 </p>

 <img src="../images/arduino_oscil.jpg" class="foc" tabindex="1">

 <pre>
  <code style = "color: green"   >
    //сырой скетч с меню вольтметром и осцилом
    #define USE_SSD1306 // Use I2C OLED screen on SSD1306 chipset
    #include "U8g2lib.h"
    const uint8_t bufferSize = 128;
    const uint8_t pinAnalogIn = A7;
    uint8_t buffer[bufferSize];
    U8G2_SH1106_128X32_VISIONOX_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
    float val = 0;
    unsigned long timer;
    unsigned long timer2;
    unsigned long timer3;
    unsigned long timer4;
    unsigned long timer5;
    unsigned long timer6;
    unsigned long timer7;
    unsigned long timer8;
    int n = 9;
    int q = 0;
    int w = 3;
    int g = 20;
    int u = 0;
    int e = 0;
    int r = 0;
    int k = 10000;
    int t = 0;
    int m = 5;
    int z = 100;
    void setup() {
      pinMode(12, INPUT_PULLUP);
      pinMode(10, INPUT_PULLUP);
      pinMode(A7, INPUT);
      // Инициализируем дисплей
      u8g2.begin();
      // Очищаем память
      u8g2.clearBuffer();
      // Выбираем шрифт
      u8g2.setFont(u8g2_font_10x20_te); //   u8g2_font_luBIS08_tr  u8g2_font_ncenR08_tr  u8g2_font_4x6_tr
      // Указываем положение курсора
      u8g2.setCursor(0, 13);
      // Выводим строку
      u8g2.print("<  VIBOR  >");
      u8g2.setCursor(0, 32);
      u8g2.print(". . . . . .");
      // Отсылаем данные на дисплей
      u8g2.sendBuffer();
    }
    void loop() {
      if (digitalRead(12) == 0) {
        q++;
        u = 0;
        r = 0;
        e = 0;
        delay(500);
      }
      if (digitalRead(10) == 0) {
        m = m + 10;
        if (m > 35)m = 5;
        if (m == 5) z = 100;
        if (m == 15) z = 300;
        if (m == 25) z = 500;
        if (m == 35) z = 700;
        delay(500);
      }
      if (u == 0 && q == 1 ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("VOLTMETR");
        u8g2.setCursor(0, 32);
        u8g2.print("| . . . . .");
        u8g2.sendBuffer();
        timer = millis();
        u = 1;
        r = 0;
      }
      if (u == 0 && q == 2 ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("OSCILOGRAF");
        u8g2.setCursor(0, 32);
        u8g2.print(". | . . . .");
        u8g2.sendBuffer();
        timer7 = millis();
        u = 1;
        r = 0;
      }
      if ( u == 0 && q == 3  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("SHASTOTOMER");
        u8g2.setCursor(0, 32);
        u8g2.print(". . | . . .");
        u8g2.sendBuffer();
        timer3 = millis();
        u = 1;
      }
      if ( u == 0 && q == 4  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("GENERATOR");

        u8g2.setCursor(0, 32);
        u8g2.print(". . . | . .");
        u8g2.sendBuffer();
        timer4 = millis();
        u = 1;
      }
      if ( u == 0 && q == 5  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("FORSYNKI");

        u8g2.setCursor(0, 32);
        u8g2.print(". . . . | .");
        u8g2.sendBuffer();
        timer5 = millis();
        u = 1;
      }
      if ( u == 0 && q == 6  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("DPKV 60 - 2");
        u8g2.setCursor(0, 32);
        u8g2.print(". . . . . |");
        u8g2.sendBuffer();
        timer6 = millis();
        u = 1;
      }
      if (q >= 7) {
        q = 1;
      }
      ///////////////////////////////////////////////////////////////////////////
      if (r == 1 && e == 2)  {  // короткий путь до вольтметра
      if (millis() - timer7 > 500 ) {
        timer7 = millis();
        voltmetr();
      }
    }
    if (millis() - timer > 3000 && q == 1 && r == 0)  { // если выбран вольтметр
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    voltmetr();
  }
  if (u == 0 && q == 0 && millis() - timer8 > 3000) { // само заходит в вольтметр если ничего не нажато
  u8g2.clearBuffer();
  u8g2.sendBuffer();
  u = 1;
  q = 1;
  voltmetr();
}
////////////////
if (millis() - timer7 > 3000 && q == 2 && r == 0)  { // если выбран осцилограф
u8g2.clearBuffer();
u8g2.sendBuffer();
timer7 = millis();
oscilograf();
}
if (r == 1 && e == 3)  {  // короткий путь до осцилограф
oscilograf();
}
}
////////////////////////////////////////////////////////////////////////////////////////
void voltmetr() {
  val = analogRead(A7);
  val = (50 / 1023.0) * val;
  u8g2.setCursor(0, 13);
  u8g2.print("VOLTMETR");
  u8g2.setCursor(0, 32);
  u8g2.print(val);
  u8g2.print(" volt     ");
  u8g2.sendBuffer();
  r = 1;
  e = 2;
}
void oscilograf() {
  uint32_t start = micros();
  for (uint8_t x = 0; x < bufferSize; ++x) {
    buffer[x] = map(analogRead(pinAnalogIn), 0, z, u8g2.getDisplayHeight() - 1, 0);
  }
  u8g2.firstPage();
  do {
    drawScreen(start);
  } while (u8g2.nextPage());
  r = 1;
  e = 3;
}
void drawScreen(uint32_t duration) {
  for (int8_t v = 5; v >= 0; --v) {
    uint8_t tickY = u8g2.getDisplayHeight() - u8g2.getDisplayHeight() * v / 5;
    for (uint8_t x = 0; x < u8g2.getDisplayWidth(); x += 8)
    u8g2.drawPixel(x, tickY);
  }
  for (uint8_t x = 1; x < bufferSize; ++x) {
    u8g2.drawLine(x - 1, buffer[x - 1], x, buffer[x]);
  }
  u8g2.setCursor(0, 13);
  u8g2.print(m);
}
</code>
</pre>
<p> Внешний вид платы контрольки с меню и разводкой на монтажной плате, фото сделаны с тестового образца где ардуино и экран сделаны съемными для удобства разработки, в дальнейшем для установки в корпус все будет запаиватся в плату. Перемычки паял проводом от витой пары, можно так же использовать жилы от провода которые потолще. Ножки кнопок пришлось подточить надфилем чтоб вошли в плату, отверстия тоже чуть расширил. Плату монтажную лучше брать двустороннюю так как на такой как на фото при пайке отпадывают пятачки если перегреть.</p>
<img src="../images/Arduino_oscilog.jpg" class="foc" tabindex="1">
</div>






<div class="divdiv di"><a name="kontrolka2"></a><p><b>Второй вариант многофункциональной контрольки с осцилографом.</b>(другие варианты ниже) <br/><br/>Выкладываю как есть, пока 3 функции вольтметр и осцилограф, частотомер доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, тест форсунок, генератор ШИМ, частотомер, генератор дпкв 60 -2.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
 <br/><br/> Защит каких либо не будет в первой версии точно, сгорит будет интерес починить, компоненты копеечные.
 Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет), лучше брать для изготовления ардуино нано с USB Type-C разьемом так как планируется нагрузка по минусу до 1 ампера.
 На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
 Питание с аккумулятора не планируется для простоты, все питание от авто.
 Генератор планируется с частотой до 1 килогерца и шим 0-100%.
 Тестер форсунок выдает импульсы в течении одой секуды что позволяет промерить относительный расход форсунки без снятия и без сканера с такой функцией  по падению давления на манометре.
 <br/><br/>
 Сам скетч контрольки в файле для скачивания <a href="../files/kontrolka2.zip" download>   скачать   </a><br/>
 Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
 <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
 <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
 <br/>
 Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
 <br/>
 Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
 <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
 <br/><br/>
 В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
 Его можно легко купить, а так же выковырять со старых импульсных блоков питания
</p>

<img src="../images/arduino_oscil2.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор для проверки на пине 13 выводим тестовый сгнал частоты на 13 пин 100 герц , шим 50%, длительность 50секунд .</b>
<pre>
  <code style = "color: green"   >
    //сырой скетч с меню вольтметром и осцилом и частотометром 2 версия
    #define USE_SSD1306 // Use I2C OLED screen on SSD1306 chipset
    #include "U8g2lib.h"
    const uint8_t bufferSize = 128;
    const uint8_t pinAnalogIn = A7;
    uint8_t buffer[bufferSize];
    U8G2_SH1106_128X32_VISIONOX_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
    float val = 0;
    unsigned long timer;
    unsigned long timer2;
    unsigned long timer3;
    unsigned long timer4;
    unsigned long timer5;
    unsigned long timer6;
    unsigned long timer7;
    unsigned long timer8;
    int n = 9;
    int q = 0;
    int w = 3;
    int g = 20;
    int u = 0;
    int e = 0;
    int r = 0;
    int k = 10000;
    int t = 0;
    int m = 5;
    int z = 100;
    int Htime = 0;            // переменная целого типа для хранения длительности высокого уровня
    int Ltime = 0;              // переменная целого типа для хранения длительности низкого уровня
    float Ttime;            // переменная для хранения длительности периода
    float rtime;            // переменная для хранения длительности периода
    int freq;        // переменная для хранения значения частоты
    int pwm;        // переменная для хранения значения частоты
    float proc;        // переменная для хранения значения частоты
    void setup() {
      //  Serial.begin(9600);
      pinMode(12, INPUT_PULLUP);
      pinMode(10, INPUT_PULLUP);
      pinMode(A7, INPUT);
      pinMode(4, INPUT); // контакт 8 конфигурируем на ввод данных частотомер
      pinMode(LED_BUILTIN, OUTPUT);
      // Инициализируем дисплей
      u8g2.begin();
      // Очищаем память
      u8g2.clearBuffer();
      // Выбираем шрифт
      u8g2.setFont(u8g2_font_10x20_te); //   u8g2_font_luBIS08_tr  u8g2_font_ncenR08_tr  u8g2_font_4x6_tr
      // Указываем положение курсора
      u8g2.setCursor(0, 13);
      // Выводим строку
      u8g2.print("<  VIBOR  >");
      u8g2.setCursor(0, 32);
      u8g2.print(". . . . . .");
      // Отсылаем данные на дисплей
      u8g2.sendBuffer();
    }
    void loop() {
      tone(LED_BUILTIN, 100, 50000); // выводим тестовый сгнал частоты на 13 пин 100 герц , шим 50%, длительность 50секунд
      if (digitalRead(12) == 0) {
        q++;
        u = 0;
        r = 0;
        e = 0;
        delay(500);
      }
      if (digitalRead(10) == 0) {
        m = m + 10;
        if (m > 35)m = 5;
        if (m == 5) z = 100;
        if (m == 15) z = 300;
        if (m == 25) z = 500;
        if (m == 35) z = 700;
        delay(500);
      }
      if (u == 0 && q == 1 ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("VOLTMETR");
        u8g2.setCursor(0, 32);
        u8g2.print("| . . . . .");
        u8g2.sendBuffer();
        timer = millis();
        u = 1;
        r = 0;
      }
      if (u == 0 && q == 2 ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("OSCILOGRAF");
        u8g2.setCursor(0, 32);
        u8g2.print(". | . . . .");
        u8g2.sendBuffer();
        timer7 = millis();
        u = 1;
        r = 0;
      }
      if ( u == 0 && q == 3  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("SHASTOTOMER");
        u8g2.setCursor(0, 32);
        u8g2.print(". . | . . .");
        u8g2.sendBuffer();

        timer3 = millis();
        u = 1;
        r = 0;
      }
      if ( u == 0 && q == 4  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("GENERATOR");

        u8g2.setCursor(0, 32);
        u8g2.print(". . . | . .");
        u8g2.sendBuffer();
        timer4 = millis();
        u = 1;
      }
      if ( u == 0 && q == 5  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("FORSYNKI");

        u8g2.setCursor(0, 32);
        u8g2.print(". . . . | .");
        u8g2.sendBuffer();
        timer5 = millis();
        u = 1;
      }
      if ( u == 0 && q == 6  ) {
        u8g2.clearBuffer();
        u8g2.setCursor(0, 13);
        u8g2.print("DPKV 60 - 2");
        u8g2.setCursor(0, 32);
        u8g2.print(". . . . . |");
        u8g2.sendBuffer();
        timer6 = millis();
        u = 1;
      }
      if (q >= 7) {
        q = 1;
      }
      ///////////////////////////////////////////////////////////////////////////
      if (r == 1 && e == 2)  {  // короткий путь до вольтметра
      if (millis() - timer7 > 500 ) {
        timer7 = millis();
        voltmetr();
      }
    }
    if (millis() - timer > 3000 && q == 1 && r == 0)  { // если выбран вольтметр
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    voltmetr();
  }
  if (u == 0 && q == 0 && millis() - timer8 > 3000) { // само заходит в вольтметр если ничего не нажато
  u8g2.clearBuffer();
  u8g2.sendBuffer();
  u = 1;
  q = 1;
  voltmetr();
}
////////////////
if (millis() - timer7 > 3000 && q == 2 && r == 0)  { // если выбран осцилограф
u8g2.clearBuffer();
u8g2.sendBuffer();
timer7 = millis();
oscilograf();
}
if (r == 1 && e == 3)  {  // короткий путь до осцилограф
oscilograf();
}
////////////////
if (millis() - timer3 > 3000 && q == 3 && r == 0)  { // если выбран частотомер
u8g2.clearBuffer();
u8g2.sendBuffer();
timer3 = millis();
shastotomer();
}
if (r == 1 && e == 4)  {  // короткий путь до осцилограф
shastotomer();
}
}
////////////////////////////////////////////////////////////////////////////////////////
void shastotomer() {  // функция частотомер
Ttime = Htime + Ltime;
rtime = Ttime - Ltime;
proc =  Ttime / 100;
pwm = rtime / proc;
freq = 1000000 / Ttime; // вычисляем значение частоты учитывая что время у нас в микросекундах
u8g2.firstPage();
u8g2.setCursor(0, 13);
u8g2.print("PWM  Hz     ");
u8g2.setCursor(0, 32);
u8g2.print(pwm);
u8g2.print("   ");
u8g2.print(freq);
u8g2.sendBuffer();
if (millis() - timer5 > 1000) {
  Htime = pulseIn(4, HIGH);   // считываем длительность высокого уровня
  Ltime = pulseIn(4, LOW);     // считываем длительность низкого уровня
  timer5 = millis();
}
r = 1;
e = 4;
}
void voltmetr() {  // функция вольтметр
val = analogRead(A7);
val = (50 / 1023.0) * val;
u8g2.firstPage();
u8g2.setCursor(0, 13);
u8g2.print("VOLTMETR");
u8g2.setCursor(0, 32);
u8g2.print(val);
u8g2.print(" volt     ");
u8g2.sendBuffer();
r = 1;
e = 2;
}
void oscilograf() {  // функция осцилограф
uint32_t start = micros();
for (uint8_t x = 0; x < bufferSize; ++x) {
  buffer[x] = map(analogRead(pinAnalogIn), 0, z, u8g2.getDisplayHeight() - 1, 0);
}
u8g2.firstPage();
do {
  drawScreen(start);
} while (u8g2.nextPage());
r = 1;
e = 3;
}
void drawScreen(uint32_t duration) {  // функция для работы осцилографа
for (int8_t v = 5; v >= 0; --v) {
  uint8_t tickY = u8g2.getDisplayHeight() - u8g2.getDisplayHeight() * v / 5;
  for (uint8_t x = 0; x < u8g2.getDisplayWidth(); x += 8)
  u8g2.drawPixel(x, tickY);
}
for (uint8_t x = 1; x < bufferSize; ++x) {
  u8g2.drawLine(x - 1, buffer[x - 1], x, buffer[x]);
}
u8g2.setCursor(0, 13);
u8g2.print(m);
}

</code>
</pre>
<p> Внешний вид платы контрольки с меню и разводкой на монтажной плате, фото сделаны с тестового образца где ардуино и экран сделаны съемными для удобства разработки, в дальнейшем для установки в корпус все будет запаиватся в плату. Перемычки паял проводом от витой пары, можно так же использовать жилы от провода которые потолще. Ножки кнопок пришлось подточить надфилем чтоб вошли в плату, отверстия тоже чуть расширил. Плату монтажную лучше брать двустороннюю так как на такой как на фото при пайке отпадывают пятачки если перегреть.</p>
<p> На фото нет замыкания резистора с той желтой перемычкой у транзистора, так кажется.</p>

<img src="../images/Arduino_oscilog2.jpg" class="foc" tabindex="1">
</div>



<div class="divdiv di"><a name="kontrolka3"></a><p><b>Третий вариант многофункциональной контрольки с осцилографом.</b>(другие варианты ниже) <br/><br/><b>Внимание! электрическую схему не проверял.</b><br/><br/>Выкладываю как есть, пока 4 функции вольтметр и осцилограф, частотомер, генератор с шим доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, генератор ШИМ, частотомер, генератор дпкв 60 -2.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
 <br/><br/> Защит каких либо не будет в первой версии а может и будет, сгорит будет интерес починить, компоненты копеечные.
 Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
 На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
 3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
 Питание с аккумулятора не планируется для простоты, все питание от авто.

 <br/><br/>
 Сам скетч контрольки устарел схема тоже используйте 6 версию   </a><br/>
 Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
 <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
 <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
 <br/>
 Библиотека для шим
 <a href="../files/PWM.zip" download>   скачать   </a>
 <br/><br/>
 Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
 <br/>
 Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
 <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
 <br/><br/>
 В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
 Его можно легко купить, а так же выковырять со старых импульсных блоков питания
 <br/><br/>
 В схеме генератора шим используется мосфет транзистор 2n7000 он довольно распространен, думаю его легко найти.

</p>

<img src="../images/arduino_oscil3.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор для проверки на пине 13 выводим тестовый сгнал частоты на 13 пин 100 герц , шим 50%, длительность 50секунд .</b>

<p> фото контрольки с включенной функцией генератор и запаенной 3 кнопкой</p>


<img src="../images/Arduino_oscilog3.jpg" class="foc" tabindex="1">
</div>






<div class="divdiv di"><a name="kontrolka4"></a><p><b>Четвертый вариант многофункциональной контрольки с осцилографом.</b>(другие варианты ниже и выше)<br/><br/>Выкладываю как есть, пока пять функций вольтметр и осцилограф, частотомер, генератор с шим и подключающийся резистор на 100ом в режиме вольтметра от кнопки номер 3, так же переделал немного и проверил схему, доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, генератор ШИМ, частотомер, генератор дпкв 60 -2, нагрузка 100ом.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
 <br/><br/> Защит каких либо не будет в первой версии а может и будет, сгорит будет интерес починить, компоненты копеечные.
 Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
 На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
 3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
 В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
 Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.

 <br/><br/>
 Сам скетч контрольки устарел качайте 6 версию<br/>
 Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
 <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
 <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
 <br/>
 Библиотека для шим
 <a href="../files/PWM.zip" download>   скачать   </a>
 <br/><br/>
 Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
 <br/>
 Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
 <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
 <br/><br/>
 В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
 Его можно легко купить, а так же выковырять со старых импульсных блоков питания
 <br/><br/>
 В схеме генератора с шим и подключении нагрузки используется мосфет транзистор IRF530N по крайней мере пока, другого не нашел, пришлось отпилить крепление транзистора для его уменьшения, он довольно распространен, думаю его легко найти. Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 ом.

</p>

<img src="../images/arduino_oscil5.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор для проверки на пине 13 выводим тестовый сгнал частоты на 13 пин 100 герц , шим 50%, длительность 50секунд .</b>

<p> фото контрольки с включенной функцией вольтрметр и нажатой третьей кнопкой включающей нагрузку, добавлен мощный резистор и транзистор, с 3 третьего пина (как в прощлой схеме ) перекинул генератор на 9 так как третий пин почему то не  стал тянуть шим, может я подпалил его может так и должно быть</p>


<img src="../images/Arduino_oscilog4.jpg" class="foc" tabindex="1">
</div>





<div class="divdiv di"><a name="kontrolka5"></a><p><b>Пятый вариант многофункциональной "народной" контрольки с осцилографом.</b>(другие варианты ниже и выше)<br/><br/>Выкладываю как есть, пока шесть функций вольтметр и осцилограф, частотомер, генератор с шим и подключающийся резистор на 100ом в режиме вольтметра от кнопки номер 3, функция определения кан лин шины, так же у вольтмера сделал усреднение значений, доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, генератор ШИМ, частотомер, кан шин тест, нагрузка 100ом.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
 <br/><br/> Защит каких либо не будет в первой версии а может и будет, сгорит будет интерес починить, компоненты копеечные.
 Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
 На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
 3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
 В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
 Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.
 <br/><br/>
 Компоненты: Arduino NANO; OLED дисплей 0.91 128x32 I2C ; kia431a (аналог TL431) в качестве тригера использован; мосфет транзистор IRF530N(можно любой n канальный); резисторы 100 ом 1 ватт 1 шт, 100 килоом 2шт, 10 килоом 2 шт, 50 килоом 1 шт, 5 килоом 1шт.

 <br/><br/>
 Сам скетч контрольки устарел качайте 6 версию<br/>
 <br/>

 Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
 <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
 <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
 <br/>
 Библиотека для шим
 <a href="../files/PWM.zip" download>   скачать   </a>
 <br/><br/>
 Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
 <a href= "https://роботехника18.рф/скачать-arduino-ide/" > Например здесь </a>
 <br/>
 <p>   Для начала лучше проверить отдельно ардуинку прошивкой блинк должен мигать встроенный в плату светодиод</p>
 <a href="../files/Blink.zip" download>   скачать  блинк </a>
 <p> Проверяем дисплей мини прошивка в ней должен идти счет </p>
 <a href="../files/test_displey.zip" download>   скачать   </a>
 <br/>
 <p> фото контрольки тестом дисплея</p>

 <img src="../images/test_displey.jpg" class="foc" tabindex="1">
 <br/><br/>
 Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
 <br/><br/>
 <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
 <br/><br/>
 В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
 Его можно легко купить, а так же выковырять со старых импульсных блоков питания
 <br/><br/>
 В схеме генератора с шим и подключении нагрузки используется мосфет транзистор IRF530N по крайней мере пока, другого не нашел, пришлось отпилить крепление транзистора для его уменьшения, он довольно распространен, думаю его легко найти. Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 килоом.

</p>

<img src="../images/arduino_oscil5.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор (отключен для экономии памяти можно включить 66 строка убрать //) для проверки на пине 13 выводим тестовый сгнал частоты .</b>

<p> фото контрольки с включенной функцией кан лин теста</p>


<img src="../images/Arduino_oscilog5.jpg" class="foc" tabindex="1">
</div>





<div class="divdiv di"><a name="kontrolka6"></a><p><b>6 Шестой вариант многофункциональной "народной" контрольки с осцилографом.</b>(другие варианты ниже и выше)<br/><br/>Выкладываю как есть, пока шесть функций вольтметр и осцилограф, частотомер, генератор с шим и подключающийся резистор на 100ом в режиме вольтметра от кнопки номер 3, функция определения кан лин шины, так же у вольтмера сделал усреднение значений, доделки в процессе.<br/> В контрольке есть(будут) функции вольтметр, осцилограф, генератор ШИМ, частотомер, кан шин тест, нагрузка 100ом.  Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
  <br/><br/>
  ИЗМЕНЕНИЯ Почищена память(21килобайт), изменен вольтметр (крупный шрифт) , в схеме установлена защита на стабилитронах.


  <br/><br/>
  <b> ЧАСТЫЕ ВОПРОСЫ, ОТВЕЧАЮ:</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО ЕСТЬ Для чего нужны функции в контрольке, если с вольтметром и осцилографом думаю многим все понятно то вопрос по генератору и частотомеру постоянно задают</b>
<br/><br/>
<b>Генератор нужен чтоб эмулировать сигнал датчиков например датчика скорости автомобиля, датчика давления фреона у которого давление передается скважностью таким образом можно "поднять давление фреона" и включить кондиционер для проверки, так же ШИМом управляются вентиляторы охлаждения двигателя и вентиляторы салона и при ремонте бывает необходимо без автомобиля или на холодном авто повключать их для проверки, пока хватит думаю примеров.</b>
<br/><br/>
<b>Частотомер нужен для замера параметров сигнала например у нас есть шим вентилятор мы можем замерить сигнал чтоб потом его эмулировать на столе для ремонта или у нас шим датчик фреона мы замеряем его несущую частоту и скважность и смотрим параметры давления в сканере, так же можем эту частоту создать генератором</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО НЕТ почему нет батарейки в устройстве, почему нет омметра, почему нет тепловизора и пр.</b>
<br/><br/>
<b> Батареи нет в котрольке для простоты изготовления, для того чтоб с помощью лития вы не сожги себе дом, и чтоб контролька могла валятся без дела хоть сколько времени хоть на жаре хоть на морозе не боясь что акб вспучит, возможно будут версии с акб но первая без него</b>
<br/><br/>
<b> Печатной платы нет но возможно ее доделают попытки есть, первая версия для народности и доступности будет на макетной плате</b>
<br/><br/>
<b> Провонка возможно будет но только для определение есть ли минус тут, прозвонку как и ОММЕТР нужно делать на версиях с аккумулятором </b>
<br/><br/>
  Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
  На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
  3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
  В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
  Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.
  <br/><br/>
  Компоненты: Arduino NANO; OLED дисплей 0.91 128x32 I2C ; kia431a (аналог TL431) в качестве тригера использован; мосфет транзистор IRF530N(можно любой n канальный); резисторы 100 ом 1 ватт 1 шт, 100 килоом 2шт, 10 килоом 2 шт, 50 килоом 1 шт, 5 килоом 1шт; стабилитрон 5 вольт(примерно) 1 шт, стабилитрон 36 вольт (примерно).

  <br/><br/>
  Сам скетч контрольки 6 в файле для скачивания <a href="../files/kontrolka6.zip" download>   скачать   </a>

  <br/><br/>
  Версия контрольки для разработчиков на гите (в процессе разработки), просто версия проверенная для заливки выше.
  <a  target="_blank" href= "https://github.com/indeedphp/oscitrolka" > здесь версия гита </a>


  <br/><br/>
  Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
  <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
  <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
  <br/>
  Библиотека для шим
  <a href="../files/PWM.zip" download>   скачать   </a>
  <br/><br/>
  Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
  <a  target="_blank" href= "https://роботехника18.рф/скачать-arduino-ide/" > Например здесь </a>
  <br/><br/>
  Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
  <br/>
  <p>   Для начала лучше проверить отдельно ардуинку прошивкой блинк должен мигать встроенный в плату светодиод</p>
  <a href="../files/Blink.zip" download>   скачать  блинк </a>
  <p> Проверяем дисплей мини прошивка в ней должен идти счет </p>
  <a href="../files/test_displey.zip" download>   скачать   </a>
  <br/>
  <p> фото контрольки тестом дисплея</p>

  <img src="../images/test_displey.jpg" class="foc" tabindex="1">

  <br/><br/>
  <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
  <br/><br/>
  В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
  Его можно легко купить, а так же выковырять со старых импульсных блоков питания
  <br/><br/>
  В схеме генератора с шим и подключении нагрузки используется мосфет транзистор IRF530N по крайней мере пока, другого не нашел, пришлось отпилить крепление транзистора для его уменьшения, он довольно распространен, думаю его легко найти. Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 килоом.

</p>
<a  target="_blank" href= "https://tel-spb.ru/zener_diode.html" > Подобрать стабилитрон </a>
<br/><br/>

<img src="../images/arduino_oscil6.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор (отключен для экономии памяти можно включить 66 строка убрать //) для проверки на пине 13 выводим тестовый сгнал частоты .</b>
<br/><br/>
<p> Измененый вольтметр, добавлена защита</p>


<img src="../images/Arduino_oscilog6.jpg" class="foc" tabindex="1">
<br/><br/>
<p> Проверяю вольтметр с блока питания 12 вольт</p>
<video width=500 controls><source src="../video/v6-voltmetr.mp4"type='video/mp4'></video>
  <br/><br/>
<p> Проверяю вольтметр с блока питания 12 вольт через лампу 1 ватт  и нагрузка в 100 ом</p>
<video width=500 controls><source src="../video/v6-voltmetr+N.mp4"type='video/mp4'></video>
  <br/><br/>
<p> Проверяю генератор с блока питания 12 вольт через лампу 1 ватт частота 50 герц скважность меняю</p>
<video width=500 controls><source src="../video/v6-generator.mp4"type='video/mp4'></video>


</div>

 <br/><br/>
<div class="divdiv di"><a name="kontrolka7"></a><p><b>7 СЕДЬМОЙ  вариант многофункциональной "народной" контрольки с осцилографом.</b>(другие варианты ниже и выше)<br/><br/>  функции: вольтметр, осцилограф, частотомер со скважностью, генератор с шим, подключающийся резистор на 100ом в режиме вольтметра от кнопки номер 3, функция определения кан лин шины, прозвонка на минус в режиме вольтметр при нажатии средней кнопки, подача плюса для проверки транзисторов, светодиодов и т.д<br/>   Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата на макетке, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
  <br/><br/>
  ИЗМЕНЕНИЯ Установлена пищалка (срабатывает на кнопки и прозвонку на минус), подается плюс через транзистор на иглу.


  <br/><br/>
  <b> ЧАСТЫЕ ВОПРОСЫ, ОТВЕЧАЮ:</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО ЕСТЬ Для чего нужны функции в контрольке, если с вольтметром и осцилографом думаю многим все понятно то вопрос по генератору и частотомеру постоянно задают</b>
<br/><br/>
<b>Генератор нужен чтоб эмулировать сигнал датчиков например датчика скорости автомобиля, датчика давления фреона у которого давление передается скважностью таким образом можно "поднять давление фреона" и включить кондиционер для проверки, так же ШИМом управляются вентиляторы охлаждения двигателя и вентиляторы салона и при ремонте бывает необходимо без автомобиля или на холодном авто повключать их для проверки, пока хватит думаю примеров.</b>
<br/><br/>
<b>Частотомер нужен для замера параметров сигнала например у нас есть шим вентилятор мы можем замерить сигнал чтоб потом его эмулировать на столе для ремонта или у нас шим датчик фреона мы замеряем его несущую частоту и скважность и смотрим параметры давления в сканере, так же можем эту частоту создать генератором</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО НЕТ почему нет батарейки в устройстве, почему нет омметра, почему нет тепловизора и пр.</b>
<br/><br/>
<b> Батареи нет в котрольке для простоты изготовления, для того чтоб с помощью лития вы не сожгли себе дом, и чтоб контролька могла валятся без дела хоть сколько времени хоть на жаре хоть на морозе не боясь что акб вспучит, возможно будут версии с акб но первая без него</b>
<br/><br/>
<b> Печатной платы нет но возможно ее доделают попытки есть, первая версия для народности и доступности будет на макетной плате</b>
<br/><br/>

<br/><br/>
  Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
  На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
  3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
  В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
  Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.
  <br/><br/>
  Компоненты: Arduino NANO; OLED дисплей 0.91 128x32 I2C ; kia431a (аналог TL431) в качестве тригера использован; мосфет транзистор IRF530N(можно любой n канальный); резисторы 100 ом 1 ватт 1 шт, 100 килоом 2шт, 10 килоом 2 шт, 50 килоом 1 шт, 5 килоом 1шт, 1 килоом 2шт ; стабилитрон 5 вольт(примерно) 1 шт, стабилитрон 36 вольт (примерно); транзистор 2n2222, пищалка(бипер) неактивная.

  <br/><br/>
  Сам скетч контрольки 7 в файле для скачивания <a href="../files/kontrolka7.zip" download>   скачать   </a>

  <br/><br/>
  Версия контрольки для разработчиков на гите (в процессе разработки), просто версия проверенная для заливки выше.
  <a  target="_blank" href= "https://github.com/indeedphp/oscitrolka" > здесь версия гита </a>


  <br/><br/>
  Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
  <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
  <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
  <br/>
  Библиотека для шим
  <a href="../files/PWM.zip" download>   скачать   </a>
  <br/><br/>
  Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
  <a  target="_blank" href= "https://роботехника18.рф/скачать-arduino-ide/" > Например здесь </a>
  <br/><br/>
  Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>
  <br/>
  <p>   Для начала лучше проверить отдельно ардуинку прошивкой блинк должен мигать встроенный в плату светодиод</p>
  <a href="../files/Blink.zip" download>   скачать  блинк </a>
  <p> Проверяем дисплей мини прошивка в ней должен идти счет </p>
  <a href="../files/test_displey.zip" download>   скачать   </a>
  <br/>
  <p> фото контрольки тестом дисплея</p>

  <img src="../images/test_displey.jpg" class="foc" tabindex="1">

  <br/><br/>
  <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
  <br/><br/>
  В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
  Его можно легко купить, а так же выковырять со старых импульсных блоков питания
  <br/><br/>
  В схеме генератора с шим и подключении нагрузки используется мосфет транзистор IRF530N по крайней мере пока, другого не нашел, пришлось отпилить крепление транзистора для его уменьшения, он довольно распространен, думаю его легко найти. Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 килоом.

</p>
<a  target="_blank" href= "https://tel-spb.ru/zener_diode.html" > Подобрать стабилитрон </a>
<br/><br/>

<img src="../images/arduino_oscil7.jpg" class="foc" tabindex="1">
<br/><br/>
<b>Добавлен генератор (отключен для экономии памяти можно включить 66 строка убрать //) для проверки на пине 13 выводим тестовый сгнал частоты .</b>
<br/><br/>
<p> Добавлена пищалка (пока навесиком) , в режиме вольтметра + на экране охначает сто идет плюс на иглу и работает прозвонка если упадет напряжение до нуля. Измененная схема добавлено два резистора и транзистор</p>


<img src="../images/Arduino_oscilog7.jpg" class="foc" tabindex="1">
<br/><br/>
<p> Проверя пищалку, прозвонку и подачу плюса</p>
<video width=500 controls><source src="../video/v7-voltmetr+5v.mp4"type='video/mp4'></video>
  <br/><br/>



</div>


</div>

 <br/><br/>
<div class="divdiv di"><a name="kontrolka8"></a><p><b>8 ВОСЬМОЙ   вариант многофункциональной "народной" контрольки с осцилографом.</b>(другие варианты ниже и выше)
  <br/><br/>
   функции: вольтметр, осцилограф, частотомер со скважностью, генератор с шим, подключающийся резистор на 100ом в режиме вольтметра от кнопки номер 3, функция определения кан лин шины, прозвонка на минус в режиме вольтметр при нажатии средней кнопки, подача плюса для проверки транзисторов, светодиодов и т.д; функция таймер для подачи импульса разной длительностью через разный промежуток до 98 секунд; тестовый генератор при нажатии 1+3 кнопки одновременно для выдачи плюсового сигнала на иглу.<br/> <br/>   Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата на макетке, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
  <br/><br/>
  ИЗМЕНЕНИЯ В ЭТОЙ ВЕРСИИ: функция таймер, функция тестовый генератор, отключение пищалки, убран резистор подтяжки для генератора, улучшен вольтметр


  <br/><br/>
  <b> ЧАСТЫЕ ВОПРОСЫ, ОТВЕЧАЮ:</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО ЕСТЬ Для чего нужны функции в контрольке, если с вольтметром и осцилографом думаю многим все понятно то вопрос по генератору и частотомеру постоянно задают</b>
<br/><br/>
<b>Генератор нужен чтоб эмулировать сигнал датчиков например датчика скорости автомобиля, датчика давления фреона у которого давление передается скважностью таким образом можно "поднять давление фреона" и включить кондиционер для проверки, так же ШИМом управляются вентиляторы охлаждения двигателя и вентиляторы салона и при ремонте бывает необходимо без автомобиля или на холодном авто повключать их для проверки, пока хватит думаю примеров.</b>
<br/><br/>
<b>Частотомер нужен для замера параметров сигнала например у нас есть шим вентилятор мы можем замерить сигнал чтоб потом его эмулировать на столе для ремонта или у нас шим датчик фреона мы замеряем его несущую частоту и скважность и смотрим параметры давления в сканере, так же можем эту частоту создать генератором</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО НЕТ почему нет батарейки в устройстве, почему нет омметра, почему нет тепловизора и пр.</b>
<br/><br/>
<b> Батареи нет в котрольке для простоты изготовления, для того чтоб с помощью лития вы не сожгли себе дом, и чтоб контролька могла валятся без дела хоть сколько времени хоть на жаре хоть на морозе не боясь что акб вспучит, возможно будут версии с акб но первая без него</b>
<br/><br/>
<b> Печатной платы нет но возможно ее доделают попытки есть, первая версия для народности и доступности будет на макетной плате</b>
<br/><br/>

<br/><br/>
  Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
  На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
  3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%.
  В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
  Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.
  <br/><br/>
  Компоненты: Arduino NANO; OLED дисплей 0.91 128x32 I2C ; kia431a (аналог TL431) в качестве тригера использован; мосфет транзистор IRF530N(можно любой n канальный); резисторы 100 ом 1 ватт 1 шт, 100 килоом 2шт, 10 килоом 2 шт, 50 килоом 1 шт, 5 килоом 1шт, 1 килоом 2шт ; стабилитрон 5 вольт(примерно) 1 шт, стабилитрон 36 вольт (примерно); транзистор 2n2222, пищалка(бипер) неактивная.

  <br/><br/>
  Сам скетч контрольки 8 в файле для скачивания <a href="../files/kontrolka8.zip" download>   скачать   </a>
<br/><br/>
  Сам скетч контрольки 8.1 в файле для скачивания <a href="../files/kontrolka8.1.zip" download>   скачать   </a>
  <br/>
  <p> изменена марка дисплея, добавлен переворот изображения(в функции частотомер 2 и 3 кнопкой там кнопки просто свободные были), добавлена индикация светодиодами на плате ардуино тх рх </p>
  <br/><br/>
  Версия контрольки для разработчиков на гите (в процессе разработки), просто версия проверенная для заливки выше.
  <a  target="_blank" href= "https://github.com/indeedphp/oscitrolka" > здесь версия гита </a>


  <br/><br/>
  Библиотеки для дисплея устанавливать обе как устанавливать смотрите есть куча видео в ютуб
  <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
  <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a>
  <br/>
  Библиотека для шим
  <a href="../files/PWM.zip" download>   скачать   </a>
  <br/><br/>
  Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
  <a  target="_blank" href= "https://роботехника18.рф/скачать-arduino-ide/" > Например здесь </a>
  <br/><br/>
  Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a>


  <br/><br/>
  <br/> Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.
  <br/><br/>
  В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
  Его можно легко купить, а так же выковырять со старых импульсных блоков питания
  <br/><br/>
  В схеме генератора с шим и подключении нагрузки используется мосфет транзистор IRF530N по крайней мере пока, другого не нашел, пришлось отпилить крепление транзистора для его уменьшения, он довольно распространен, думаю его легко найти. Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 килоом.

</p>
<a  target="_blank" href= "https://tel-spb.ru/zener_diode.html" > Подобрать стабилитрон </a>
<br/><br/>
<b>ВНИМАНИЕ в отличии от схемы сверху в версии 7 убран резистор на 10к для подтяжки плюса и включена внутренняя подтяжка плюса так частотомер работает стабильнее</b>
<br/>
<img src="../images/arduino_oscil8.jpg" class="foc" tabindex="1">
<br/><br/>


<p> функция таймер, включение тестового генератора, выключение пищалки</p>


<img src="../images/Arduino_oscilog8.jpg" class="foc" tabindex="1">
<br/><br/>
<p> Проверка функции таймер и тд.</p>
<video width=500 controls><source src="../video/v8-timer.mp4"type='video/mp4'></video>
  <br/><br/>



</div>




</div>

 <br/><br/>
<div class="divdiv di"><a name="kontrolka9"></a><p><b>9 ДЕВЯТЫЙ   вариант многофункциональной "народной" контрольки с осцилографом.(другие варианты ниже и выше)<br/><br/>
ВНИМАНИЕ!!! СХЕМА ОТ ПРЕДЫДУЩИХ ВЕРСИЙ НЕ ПОДОЙДЕТ ТАК КАК ИЗМЕНЕНА РАСПИНОВКА ЕСЛИ ЗАЛЬЕТЕ ТО РИСКУЕТЕ ПРИ НАЖАТИИ КНОПКИ СЖЕЧЬ АРДУИНО, ТАК ЖЕ ИЗМЕНЕНЫ НЕКОТОРЫЕ ДЕТАЛИ.


</b>
  <br/><br/>
   функции: вольтметр, осцилограф, частотомер со скважностью, генератор с шим выдающий как минусовые импульсы так и плюсовые + 5в , подключающийся резистор в качестве нагрузки на 100ом в режиме вольтметра(3 кнопка в вольтметре), функция определения кан лин шины, прозвонка на минус в режиме вольтметр при нажатии средней кнопки, подача плюса для проверки транзисторов, светодиодов и т.д; функция таймер для подачи импульса разной длительностью через разный промежуток до 98 секунд(как плюса +5 в так и минуса); тестовый генератор при нажатии 1+3 кнопки одновременно для выдачи плюсового сигнала на иглу, выключение пищалки, смена полярности сигнала в генераторе и таймере<br/> <br/>   Корпус задуман из самого доступного это шприц 20-30 кубов под него и планируется плата на макетке, контролька прежде всего должна быть доступна максимальному кругу людей, так что 3д принтеры для изготовления корпуса не используются.
  <br/><br/>
  ИЗМЕНЕНИЯ В ЭТОЙ ВЕРСИИ: сделан плюсовой шим, хождение по меню в обе стороны, убран ноль в таймере и пр.



  <br/><br/>
  <b> ЧАСТЫЕ ВОПРОСЫ, ОТВЕЧАЮ:</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО ЕСТЬ Для чего нужны функции в контрольке, если с вольтметром и осцилографом думаю многим все понятно то вопрос по генератору и частотомеру постоянно задают</b>
<br/><br/>
<b>Генератор нужен чтоб эмулировать сигнал датчиков например датчика скорости автомобиля, датчика давления фреона у которого давление передается скважностью таким образом можно "поднять давление фреона" и включить кондиционер для проверки, так же ШИМом управляются вентиляторы охлаждения двигателя и вентиляторы салона и при ремонте бывает необходимо без автомобиля или на холодном авто повключать их для проверки, пока хватит думаю примеров.</b>
<br/><br/>
<b>Частотомер нужен для замера параметров сигнала например у нас есть шим вентилятор мы можем замерить сигнал чтоб потом его эмулировать на столе для ремонта или у нас шим датчик фреона мы замеряем его несущую частоту и скважность и смотрим параметры давления в сканере, так же можем эту частоту создать генератором</b>
<br/><br/>
<b> ВОПРОСЫ ПО ТОМУ ЧТО НЕТ почему нет батарейки в устройстве, почему нет омметра, почему нет тепловизора и пр.</b>
<br/><br/>
<b> Батареи нет в котрольке для простоты изготовления, для того чтоб с помощью лития вы не сожгли себе дом, и чтоб контролька могла валятся без дела хоть сколько времени хоть на жаре хоть на морозе не боясь что акб вспучит, возможно будут версии с акб но первая без него</b>
<br/><br/>
<b> Печатной платы нет но возможно ее доделают попытки есть, первая версия для народности и доступности будет на макетной плате</b>
<br/><br/>

<br/><br/>
  Питание контрольки будет через юсб разьем с преобразователем на 5 вольт в термоусадке(схема будет).
  На осциле настроен выбор 5, 15, 25, 35 вольт второй кнопкой, первой кнопкой выбор по меню функций всей контрольки.
  3 кнопка настраивает частоту в генераторе частоты от 50 до 1000 герц с шагом 50, второй кнопкой в режиме генератора настраивается шим 10%, 35%, 50%, 75%, 90%., индикация светодиодами на плате ардуино тх рх на 5 и 12 вольт.
  В режиме вольтметра если нажать третью кнопку подключается нагрузка, на экране появляется надпись об этом.
  Питание с аккумулятора не планируется для простоты, надежности и безопасности, все питание от авто.
  <br/><br/>
  Компоненты: Arduino NANO; OLED дисплей 0.91 128x32 I2C ; kia431a (аналог TL431) в качестве тригера использован; мосфет транзистор 2n7000; резисторы 100 ом 1 ватт 1 шт, 100 килоом 2шт, 10 килоом 2 шт, 50 килоом 1 шт, 5 килоом 1шт, 1 килоом 2шт ; стабилитрон 5 вольт(примерно) 1 шт, стабилитрон 36 вольт (примерно); транзистор 2n2222, пищалка(бипер) неактивная.

  <br/><br/>

  Сам скетч контрольки 9 в файле для скачивания <a href="../files/kontrolka9.zip" download>   скачать   </a>
  <br/>
  <p>Изменения в 9: сделан плюсовой шим генератор, в таймере тоже появилась возможность плюсового сигнала, в меню можно двигатся в две стороны, устанолена индикация в генераторе и таймере плюсового минусового сигнала, поворот экрана в осцилографе  3 кнопка, изменение полярности сигнала в таймере и в генераторе 2 + 3 кнопка, выключение пищалки 1+2 кнопка, 1+ 3 кнопка тестовый сигнал </p>
  <br/><p>
  Версия контрольки для разработчиков на гите (в процессе разработки), просто версия проверенная для заливки выше.
  <a  target="_blank" href= "https://github.com/indeedphp/oscitrolka" > здесь версия гита </a></p>


  <br/><p>
  Библиотеки для дисплея устанавливать обе, скачиваете, распаковываете, закидываете в C:\Program Files (x86)\Arduino\libraries
  <a href="../files/SSD1306Ascii-master.zip" download>   скачать   </a>
  <a href="../files/U8g2_Arduino-master.zip" download>   скачать   </a></p>
  <p>
  Библиотека для шим, скачиваете, распаковываете, закидываете в C:\Program Files (x86)\Arduino\libraries
  <a href="../files/PWM.zip" download>   скачать   </a></p>
  <br/>
<img src="../images/libres.jpg" class="foc" tabindex="1">
  <br/><br/><p>
  Программу для ардуино рекомендую "arduino-1.8.16-windows" найти в интернете не составит труда
  <a  target="_blank" href= "https://роботехника18.рф/скачать-arduino-ide/" > Например здесь </a></p>
  <br/><p>
  Так же возможно нужно будет поставить драйвер для платы ардуино <a href="../files/driver_ch340_341_arduino.exe" download>скачать </a></p>

  <br/> <p>Для теста поставил чистую 10 винду, установил программу Ардуино иде "arduino-1.8.16-windows", закинул в папку ардуины "libraries" две распакованных папки с библиотеками экрана, поставил драйвер для ардуино нано, и залил скетч, все проверено.</p>
  <br/><p>
  В схеме частотометра использован стабилизатор kia431a (аналог TL431) включенный как тригер, если интересно в ютубе есть по нему видео.
  Его можно легко купить, а так же выковырять со старых импульсных блоков питания</p>
  <br/><p>
  Генератор работает замыканием иглы на минус через резистор , таким образом можно просаживать сигнальные линии с питанием, для линий без питания можно подкинуть питание через резистор 5-10 килоом </p>

</p>

<br/><p>
<b>ВНИМАНИЕ схема изменена , распиновка ардуино другая, так же заменен резистор на частотомере со 100к на 500к для уменьшения входного сопротивления, так же заменен транзистор мосфет IRF530N на 2n7000(лучше взять BSS292, BS170, BS270 только смотрите по распиновке)</b>
<a  target="_blank" href= "https://tel-spb.ru/zener_diode.html" > Подобрать стабилитрон </a>
 <p>
<br/>
<img src="../images/arduino_oscil9.jpg" class="foc" tabindex="1">
<br/>
<p>Схема сборки на макетной плате 2см на 19см , 7 отверстий на 35 отверстий</p>

<img src="../images/arduino_maket9.jpg" class="foc" tabindex="1">
<br/>
<p>
<b>НАЙДЕТЕ НЕТОЧНОСТИ ПРОСЬБА НАПИШИТЕ В ТЕЛЕГРАМ КАНАЛ</b>

 <p>

<p> фото платы на макетке</p>


<img src="../images/Arduino_oscilog9.jpg" class="foc" tabindex="1">
<br/><br/>



<pre>
  <code style = "color: green"   >
//сырой скетч 9 версия
// ВЕРСИЯ ПОД ДРУГУЮ ПЛАТУ ОТ 8 НЕ ПОДОЙДЕТ, ДРУГАЯ РАСПИНОВКА
//сделан плюсовой шим, хождение по меню в обе стороны, убран ноль в таймере и пр.
#define USE_SSD1306 // Use I2C OLED screen on SSD1306 chipset
#include "U8g2lib.h"
#include <PWM.h>
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE, /* clock=*/ SCL, /* data=*/ SDA); // норм поворот и без точек
byte led = 10;                 // пин генератора 10 - минус по умолчанию, 9 пин генератор +
int frequency = 50;          // начальная частота  на генераторе
byte brightness = 25;         // начальная частота ШИМ (0-255)
byte buffer[128];
unsigned long timer;
const PROGMEM char caption_voltmeter[]      = "VOLTMETER";   //складываем строки во флеш память освобождая оперативку
const PROGMEM char caption_oscilloscope[]   = "OSCILLOSCOPE";
const PROGMEM char caption_freq[]           = "FREQUENCE";
const PROGMEM char caption_generator[]      = "GENERATOR";
const PROGMEM char caption_canlintst[]      = "CAN LIN TEST";
const PROGMEM char caption_timer[]          = "TIMER";
const PROGMEM char slider_voltmeter[]       = "| . . . . . .";
const PROGMEM char slider_oscilloscope[]    = ". | . . . . .";
const PROGMEM char slider_freq[]            = ". . | . . . .";
const PROGMEM char slider_generator[]       = ". . . | . . .";
const PROGMEM char slider_canlintst[]       = ". . . . | . .";
const PROGMEM char slider_timer[]           = ". . . . . | .";
byte jdem;    // для таймера
byte impyls;   // для таймера
byte s = 16;  // пин А2(16) меняется на другой для отключения пищалки
byte b = 0;
boolean x = 0;
boolean y = 0;
boolean t = 0;
byte n = 1;
byte g = 1;
byte q = 1;
byte u = 0;
byte e = 0;
byte r = 0;
byte k = 10;     //  на генераторе частоту отображает
byte m = 5;      //  инфа на осцилографе
byte p = 1;      // счетчик кнопки 2
int w = 100;
int Htime = 0;   // переменная целого типа для хранения длительности высокого уровня
int Ltime = 0;   // переменная целого типа для хранения длительности низкого уровня
float Ttime;     // переменная для хранения длительности периода
float rtime;     // переменная для хранения длительности периода
int freq;        // переменная для хранения значения частоты
int pwm;         // переменная для хранения значения частоты
float proc;      // переменная для хранения значения частоты
void setup() {
  InitTimersSafe();           // запускаем таймер
  pinMode(12, INPUT_PULLUP);  // 3 кнопка
  pinMode(A1, INPUT_PULLUP);  // 2 кнопка
  pinMode(A0, INPUT_PULLUP);  // 1 кнопка
  pinMode(A2, OUTPUT);        // пин а0 пищалка
  pinMode(10, OUTPUT);        // пин 10 выход на генератор +
  pinMode(9, OUTPUT);         // пин 9 выход на генератор -
  pinMode(0, OUTPUT);         // светодиод на плате тх
  pinMode(1, OUTPUT);         // светодиод а плате рх
  pinMode(13, OUTPUT);        // пин 13 светодиод а плате
  pinMode(A7, INPUT);         // пин а7 вольтметр и осцилограф
  pinMode(2, INPUT_PULLUP);   // пин 2 ввод данных частотомер
  pinMode(9, OUTPUT);         // пин 9 выход на генератор
  digitalWrite(1, HIGH);      // выключаем изначально светордиод рх
  u8g2.begin();                          // Инициализируем дисплей
  //  u8g2.setDisplayRotation(U8G2_R2);  // преворачиваем изображение
  u8g2.setFont(u8g2_font_10x20_mr);      // Выставляем шрифт (шрифты жрут прорву памяти так что аккуратнее если меняете)
  u8g2.setCursor(0, 13);
  u8g2.print("OSCITROLKA");
  u8g2.setCursor(25, 32);
  u8g2.print("V 1. 9.");
  u8g2.sendBuffer();                 // Отсылаем данные на дисплей
  tone(A2, 349, 204.54525);  //  Проигрываем мелодию
  delay(227.2725);
  tone(A2, 349, 204.54525);
  delay(227.2725);
  tone(A2, 349, 102.272625);
  delay(113.63625);
  tone(A2, 391, 102.272625);  //
  delay(113.63625);
  tone(A2, 329, 204.54525);
  delay(227.2725);
  tone(A2, 329, 204.54525);
  delay(227.2725);
  tone(A2, 293, 102.272625);
  delay(113.63625);
  tone(A2, 261, 102.272625);
  delay(113.63625);
  tone(A2, 293, 306.817875);  // конец мелодии
}
void loop() {
  //tone(13, 100, 50000); // выводим тестовый сгнал частоты на 13 пин 100 герц , шим 50%, при включении не работает пищалка
  ///////////////// 1 КНОПКА
  if (digitalRead(A0) == 0) { // 1 верхняя кнопка, обработка нажатия
    tone(s, 500, 100);
    u8g2.setFont(u8g2_font_10x20_mr);
    pwmWrite(led, 0);
    SetPinFrequency(led, 0);
    q++;
    u = 0;
    r = 0;
    e = 0;
    if (q >= 8) {  // меню возращаемся к 1 пункту
      q = 1;
    }
    timer = millis();
    delay(500) ;
  }
  ///////////////
  if (r == 0 && digitalRead(12) == 0) { // крутим меню обратно
    tone(s, 500, 100);
    q--;
    u = 0;
    if (q <= 0) {  // меню возращаемся к последнему пункту
      q = 7;
    }
    timer = millis();
    delay(500) ;
  }
  ///////////////
  if (e == 3 && digitalRead(12) == 0) { //
    tone(s, 500, 100);

    if (t == 1) { //  переворачиваем экран если нажата кнопка 2
      t = 0;
      u8g2.setDisplayRotation(U8G2_R0);
    }
    else { // в
      t = 1;
      u8g2.setDisplayRotation(U8G2_R2);
    }
    u8g2.sendBuffer();

    delay(500) ;
  }
  ////////1+3 КНОПКА
  if (r == 0 && digitalRead(A0) == 0 && digitalRead(12) == 0) { // 1+3 кнопка включаем импульсы + 35герц 50% скважность
    digitalWrite(10, 0);
    digitalWrite(9, 0);
    u8g2.firstPage();
    u8g2.setCursor(0, 13);
    if (y == 0) {
      y = 1;
      tone(9, 35);  // на 9 пине создаем сигнал
      u8g2.print("ON TEST SIG");
    }
    else {
      y = 0;
      noTone(9);
      u8g2.print("NO TEST SIG");
    }
    u8g2.sendBuffer();
    delay(1000) ;
  }
  ///////// 1+2 КНОПКА
  if (r == 0 && digitalRead(A0) == 0 && digitalRead(A1) == 0) { // 1+2 кнопка выключаем пищалку

    u8g2.firstPage();
    u8g2.setCursor(0, 13);
    if (s == 16) {
      s = 17;
      u8g2.print("TONE OFF");
    }
    else {
      s = 16;
      u8g2.print("TONE ON");
    }
    u8g2.sendBuffer();
    delay(1000) ;
  }
  ////////// 2+3 КНОПКА
  if (r == 0 && digitalRead(A1) == 0 && digitalRead(12) == 0) { // 2+3 кнопка

    u8g2.firstPage();
    u8g2.setCursor(0, 13);
    if (x == 0) {
      x = 1;
      led = 9;
      u8g2.print(" + GEN");
    }
    else {
      x = 0;
      led = 10;
      u8g2.print(" - GEN");
    }
    u8g2.sendBuffer();
    delay(1000) ;
  }
  //////////////////////// 2 КНОПКА
  if (e == 7 && digitalRead(A1) == 0) { // 2 кнопка от юсб разьема обработажатия
    tone(s, 700, 100);
    b++;
    g++;
    if (b >= 3) g = g + 5;     // прибавляем по 5 к таймеру при удержании кнопки
    if (g >= 99)g = 1;
    delay(500);
    if (e == 7 && digitalRead(A1) == 1)b = 0;
  }
  ///////
  if (e == 5 && digitalRead(A1) == 0 || e == 3 && digitalRead(A1) == 0 ) { // 2 кнопка от юсб разьема обработка нажатия
    p++;
    tone(s, 600, 100);
    if (p >= 6) {
      p = 1;
    }
    if (p == 1) {
      w = 100;
      m = 5;
      brightness = 25;  // 10% PWM
      k = 10;
    }
    if (p == 2  && e == 3) {  // пропускаем шаг настройки для осцилографа
      p = 3;
    }
    if (p == 2) {
      m = 5;
      w = 100;
      brightness = 89; // 35% PWM
      k = 35;
    }
    if (p == 3) {
      m = 15;
      w = 300;
      brightness = 127;  // 50% PWM
      k = 50;
    }
    if (p == 4) {
      m = 25;
      w = 500;
      brightness = 191;  // 75% PWM
      k = 75;
    }
    if (p == 5) {
      m = 35; // осцилограф максимум вольт
      w = 700;
      brightness = 229;  // 90% PWM
      k = 90;
    }
    delay(500);
  }
  //////
  if (e == 2 && digitalRead(A1) == 0 ) { // 2 кнопка  от юсб разьема в режиме вольтметр включаем подачу плюса на иглу
    digitalWrite(10, 0);
    tone(s, 700, 100);
    if (digitalRead(9) == 0) digitalWrite(9, 1); // если
    else digitalWrite(9, 0);
    delay(500);
  }

  //////////////////// 3 КНОПКА
  if (e == 7 && digitalRead(12) == 0) { // 3 кнопка от юсб в режиме таймер
    tone(s, 700, 100);
    n++;
    b++;
    if (b >= 3) n = n + 5;  // прибавляем по 5 к таймеру при удержании кнопки
    if (n >= 99)n = 1;
    delay(500);
    if (e == 7 && digitalRead(12) == 1)b = 0;
  }
  /////
  if (e == 5 && digitalRead(12) == 0) { // 3 кнопка от юсб в режиме генератор
    tone(s, 700, 100);
    frequency = frequency + 50;
    if (frequency >= 1050)frequency = 50;
    delay(500);
  }
  /////
  if (e == 2 && digitalRead(12) == 0 ) { // 3 кнопка от юсб разьема в режиме вольтметр
    tone(s, 700, 100);
    digitalWrite(9, 0); // выклюаем подачу плюса на иглу
    if (digitalRead(10) == 0) digitalWrite(10, 1); //включаем подачу минуса на иглу
    else digitalWrite(10, 0);  // выклюаем подачу минуса на иглу
    delay(500);
  }

  /////////////////////// ВОЛЬТМЕР
  if (u == 0 && q == 1 ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_voltmeter) + 1];  // вытаскиваем из флеша строку вольтметр
    strcpy_P(buf, caption_voltmeter);           // вытаскиваем из флеша строку вольтметр
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_voltmeter) + 1];
    strcpy_P(buf_w, slider_voltmeter);
    u8g2.print(buf_w);
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;
  }
  /////////////////////// ОСЦИЛОГРАФ
  if (u == 0 && q == 2 ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_oscilloscope) + 1];
    strcpy_P(buf,  caption_oscilloscope);
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_oscilloscope) + 1];
    strcpy_P(buf_w, slider_oscilloscope);
    u8g2.print(buf_w);
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;
  }
  /////////////////////// ЧАСТОТОМЕР
  if ( u == 0 && q == 3  ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_freq) + 1];
    strcpy_P(buf,  caption_freq);
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_freq) + 1];
    strcpy_P(buf_w, slider_freq);
    u8g2.print(buf_w);
    u8g2.sendBuffer();

    timer = millis();
    u = 1;
    r = 0;
  }
  /////////////////////// ГЕНЕРАТОР
  if ( u == 0 && q == 4  ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_generator) + 1];
    strcpy_P(buf,  caption_generator);
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_generator) + 1];
    strcpy_P(buf_w, slider_generator);
    u8g2.print(buf_w);
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;
  }
  /////////////////////// CAN LIN TEST
  if ( u == 0 && q == 5  ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_canlintst) + 1];
    strcpy_P(buf,  caption_canlintst);
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_canlintst) + 1];
    strcpy_P(buf_w, slider_canlintst);
    u8g2.print(buf_w);
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;
  }
  /////////////////////// TIMER
  if ( u == 0 && q == 6  ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);
    char buf[strlen_P(caption_timer) + 1];
    strcpy_P(buf,  caption_timer);
    u8g2.print(buf);
    u8g2.setCursor(0, 32);
    char buf_w[strlen_P(slider_timer) + 1];
    strcpy_P(buf_w, slider_timer);
    u8g2.print(buf_w);
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;;
  }
  //////////////

  /////////////////////// ?????
  if ( u == 0 && q == 7  ) {
    u8g2.clearBuffer();
    u8g2.setCursor(0, 13);

    u8g2.print("   ???  ");
    u8g2.setCursor(0, 32);

    u8g2.print(". . . . . . |");
    u8g2.sendBuffer();
    timer = millis();
    u = 1;
    r = 0;;
  }
  //////////////

  //  if (q >= 8) {  // меню возращаемся к 1 пункту
  //    q = 1;
  //  }
  ///////////////////////////////////////////////////////////////////////////
  if (r == 1 && e == 2)  {  // короткий путь до вольтметра
    voltmetr();
  }
  if (millis() - timer > 3000 && q == 1 && r == 0)  { // если выбран вольтметр
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    voltmetr();
  }
  ////////////////
  if (r == 1 && e == 3)  {  // короткий путь до осцилограф
    oscilograf();
  }
  if (millis() - timer > 3000 && q == 2 && r == 0)  { // если выбран осцилограф
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    oscilograf();
  }
  ////////////////
  if (r == 1 && e == 4)  {  // короткий путь до частотомер
    shastotomer();
  }
  if (millis() - timer > 3000 && q == 3 && r == 0)  { // если выбран частотомер
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    shastotomer();
  }
  ////////////////
  if (r == 1 && e == 5)  {  // короткий путь до генератор
    generator();
  }
  if (millis() - timer > 3000 && q == 4 && r == 0)  { // если выбран генератор
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    generator();
  }
  ////////////////
  if (r == 1 && e == 6)  {  // короткий путь до кан лин тест
    can_lin_test();
  }
  if (millis() - timer > 3000 && q == 5 && r == 0)  { // если выбран кан лин тест
    u8g2.clearBuffer();
    u8g2.sendBuffer();
    timer = millis();
    can_lin_test();
  }
  ////////////////
  if (r == 1 && e == 7)  {  // короткий путь до таймер
    timers();
  }
  if (millis() - timer > 2000 && q == 6 && r == 0)  { // если выбран таймер
    jdem = n + 1;
    impyls = g;
    timer = millis();
    timers();
  }
}
////////////////////////////////////////////////////////////////////////////////////////
void shastotomer() {  // функция частотомер
  Ttime = Htime + Ltime;
  rtime = Ttime - Ltime;
  proc =  Ttime / 100;
  pwm = rtime / proc;
  freq = 1000000 / Ttime; // вычисляем значение частоты учитывая что время у нас в микросекундах
  u8g2.firstPage();
  u8g2.setCursor(0, 13);
  u8g2.print("PWM  Hz     ");
  u8g2.setCursor(0, 32);
  u8g2.print(pwm);
  u8g2.print("   ");
  u8g2.print(freq);
  u8g2.sendBuffer();
  if (millis() - timer > 1000) {
    Htime = pulseIn(2, HIGH);   // считываем длительность высокого уровня
    Ltime = pulseIn(2, LOW);     // считываем длительность низкого уровня
    timer = millis();
  }
  r = 1;
  e = 4;
}
///////////////////////////////
void generator() {  // функция генератор

  u8g2.firstPage();
  u8g2.setCursor(0, 13);
  u8g2.print(k);
  if (led == 9)u8g2.print("  PWM +");
  else u8g2.print("  PWM -");
  u8g2.setCursor(0, 32);
  u8g2.print(frequency);
  u8g2.print("  Hz");
  u8g2.sendBuffer();
  pwmWrite(led, brightness);
  SetPinFrequency(led, frequency);
  r = 1;
  e = 5;
}
/////////////////////////////
void voltmetr() { // функция вольтметр
  long sum = 0;
  for (int i = 0; i < 50; i++)  sum += analogRead(A7);
  Htime = (sum / 50);
  if (Htime >= Ltime + 2 || Htime <= Ltime - 2) {
    Ltime = Htime;
  }
  Ttime = (51 / 1023.0) * Ltime;
  u8g2.firstPage();
  u8g2.setFont(u8g2_font_10x20_mr);
  u8g2.setCursor(0, 13);
  u8g2.print("V");
  if (digitalRead(10) == 1) {
    u8g2.setCursor(0, 32);
    u8g2.print("N");
  }
  digitalWrite (13, 0);
  if (digitalRead(9) == 1) {
    u8g2.setCursor(0, 32);
    u8g2.print("+");
    if (Htime <= 5) {
      tone(s, 700, 250);  // подключаем пищалку на прозвонке
      digitalWrite (13, 1);  // пождключаем светодиод на плате ардуино на прозвонке
    }
  }

  if (Htime >= 235 && Htime <= 250) digitalWrite(0, LOW); // 2 строки светим светодиодом rx  если на игле около 12 вольт
  else digitalWrite(0, HIGH);
  if (Htime >= 90 && Htime <= 100) digitalWrite(1, LOW); // 2 строки светим светодиодом  tx если на игле около 5 вольт
  else digitalWrite(1, HIGH);

  u8g2.setFont(u8g2_font_fub30_t_symbol);
  u8g2.setCursor(15, 32);
  u8g2.print(Ttime);
  u8g2.sendBuffer();
  if (Ltime <= 3)Ltime = 0;
  r = 1;
  e = 2;
}
////////////////////////
void can_lin_test() {  // кан лин тестер
  Htime = analogRead(A7);
  Serial.println(Htime);
  u8g2.firstPage();
  u8g2.setCursor(0, 13);
  u8g2.print("CAN LIN TEST");
  u8g2.setCursor(0, 32);
  if (Htime >= 20 && Htime <= 35  ) {
    u8g2.print("  < CAN L >     ");
    delay(1000);
    u8g2.sendBuffer();
  }
  if (Htime >= 90 && Htime <= 105 ) {
    u8g2.print("  < CAN H >      ");
    u8g2.sendBuffer();
    delay(1000);
  }
  if (Htime >= 150 && Htime <= 600 ) {
    u8g2.print("  < LIN >     ");
    u8g2.sendBuffer();
    delay(1000);
  }
  if (Htime >= 0 && Htime <= 10 ) {
    u8g2.print("  < TEST >      ");
    u8g2.sendBuffer();
  }
  r = 1;
  e = 6;
}
/////////////////////////функция таймер
void timers() {
  if (millis() - timer > 1000  ) {
    timer = millis();

    u8g2.firstPage();
    u8g2.setCursor(0, 13);
    u8g2.print("IMP ");
    u8g2.print(g);
    u8g2.print(" JD ");
    u8g2.print(n);
  if (impyls == 0) {
      digitalWrite(led, LOW );  // выключаем пин на время
      jdem = n + 1;
      impyls = g;
    }
    if (jdem == 1 && impyls >= 1) {
      u8g2.setCursor(0, 32);

      if (led == 9)u8g2.print("+ IMPYLS ");
      else u8g2.print("- IMPYLS ");
      u8g2.print(impyls);
      impyls--;
      tone(s, 500, 400);
      digitalWrite(led, HIGH); // включаем  пин на время
      delay(200);
    }

    else {
      jdem--;
      tone(s, 900, 50);
      u8g2.setCursor(0, 32);
      if (led == 9)u8g2.print("+ JDEM ");
      else u8g2.print("- JDEM ");
      u8g2.print(jdem);
    }
  }
  u8g2.sendBuffer();
  r = 1;
  e = 7;
}
//////////////////////////////////////
void oscilograf() {  // функция осцилограф
  uint32_t start = micros();
  for (uint8_t x = 0; x < 128; ++x) {  // 128 размер буфера
    buffer[x] = map(analogRead(A7), 0, w, u8g2.getDisplayHeight() - 1, 0); // а7 пин ацп
  }
  u8g2.firstPage();
  do {
    drawScreen(start);
  } while (u8g2.nextPage());
  r = 1;
  e = 3;
}
void drawScreen(uint32_t duration) {  // функция для работы осцилографа
  for (int8_t v = 5; v >= 0; --v) {
    uint8_t tickY = u8g2.getDisplayHeight() - u8g2.getDisplayHeight() * v / 5;
    for (uint8_t x = 0; x < u8g2.getDisplayWidth(); x += 8)
      u8g2.drawPixel(x, tickY);
  }
  for (uint8_t x = 1; x < 128; ++x) {  // 128 размер буфера
    u8g2.drawLine(x - 1, buffer[x - 1], x, buffer[x]);
  }
  u8g2.setCursor(0, 13);
  u8g2.print(m);
}

</code>
</pre>





</div>



</body>
</html>
